<!DOCTYPE html>
<html>
<head>
    <title>Grapple Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>WASD to Move | Click to Shoot | Right Click to Grapple | SPACE to Parry</h3>
        <input type="text" id="pass" placeholder="Enter Staff Key">
        <button onclick="login()">Auth</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let mouse = { x: 0, y: 0 };
        let cam = { x: 0, y: 0 };
        const keys = {};

        // INPUT HANDLERS
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX + cam.x;
            mouse.y = e.clientY + cam.y;
        });
        window.addEventListener('mousedown', e => {
            if(e.button === 0) { // Left Click
                const angle = Math.atan2(mouse.y - (window.innerHeight/2 + cam.y), mouse.x - (window.innerWidth/2 + cam.x));
                socket.emit('shoot', Math.atan2(mouse.y - myPos.y, mouse.x - myPos.x));
            }
        });
        
        // Prevent context menu for right click grapple
        window.addEventListener('contextmenu', e => e.preventDefault());

        function login() {
            const key = document.getElementById('pass').value;
            socket.emit('login', key);
        }

        let myPos = {x:0, y:0};

        // RENDER LOOP
        socket.on('state', (state) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Find my player to center camera
            const myPlayer = state.players[socket.id];
            if(myPlayer) {
                myPos = myPlayer;
                cam.x = myPlayer.x - canvas.width / 2;
                cam.y = myPlayer.y - canvas.height / 2;
            }

            ctx.save();
            ctx.translate(-cam.x, -cam.y);

            // Draw World Grid
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            for(let i=0; i<2000; i+=100) {
                ctx.moveTo(i, 0); ctx.lineTo(i, 2000);
                ctx.moveTo(0, i); ctx.lineTo(2000, i);
            }
            ctx.stroke();

            // Draw Players
            for (const id in state.players) {
                const p = state.players[id];
                
                // Grapple Line
                if (p.grapple.active) {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.grapple.x, p.grapple.y);
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }

                // Parry Shield
                if (p.parry.active) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 40, 0, Math.PI * 2);
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }

                // Player Body
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = p.role.color;
                ctx.fill();
                
                // Name/Role
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`${p.role.name} [${p.score}]`, p.x - 20, p.y - 30);
                
                // Health Bar
                ctx.fillStyle = 'red';
                ctx.fillRect(p.x - 20, p.y + 25, 40, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(p.x - 20, p.y + 25, 40 * (p.hp / p.role.hp), 5);
            }

            // Draw Bullets
            for (const b of state.bullets) {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.parried ? 8 : 5, 0, Math.PI * 2);
                ctx.fillStyle = b.parried ? 'cyan' : 'yellow';
                ctx.fill();
            }

            ctx.restore();
        });

        // SEND INPUT LOOP
        setInterval(() => {
            socket.emit('input', {
                up: keys['KeyW'],
                down: keys['KeyS'],
                left: keys['KeyA'],
                right: keys['KeyD'],
                grapple: keys['KeyQ'] || (navigator.userAgent.includes('Mac') ? keys['MetaRight'] : false), // Alternative key needed sometimes
                // Using Mouse Right Click (button 2) is handled in logic usually, 
                // but let's send Grapple status if right mouse is held
                grapple: keys['ShiftLeft'], // Let's use Shift for Grapple for simplicity in code
                parry: keys['Space'],
                mouseX: mouse.x,
                mouseY: mouse.y
            });
        }, 1000 / 60);

        // Right click listener update for loop
        let rightDown = false;
        window.addEventListener('mousedown', e => { if(e.button === 2) rightDown = true; });
        window.addEventListener('mouseup', e => { if(e.button === 2) rightDown = false; });
        
        // Override input loop to include mouse
        setInterval(() => {
            socket.emit('input', {
                up: keys['KeyW'],
                down: keys['KeyS'],
                left: keys['KeyA'],
                right: keys['KeyD'],
                grapple: rightDown, 
                parry: keys['Space'],
                mouseX: mouse.x,
                mouseY: mouse.y
            });
        }, 1000 / 60);

    </script>
</body>
</html>
